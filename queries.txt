Sharepoint Tab-Specific Test Cases
Owner Display Tests
Verify "Owners" field is replaced with two separate fields:

"Primary Owners" field is displayed

"Secondary Owners" field is displayed

Validate that the original "Owners" field is hidden

Confirm both Primary and Secondary owner fields show correct user data

Test that owner information is correctly fetched from the service

Group Settings Visibility Tests
Verify "Group Settings" section is completely hidden when Sharepoint tab is selected

Confirm the following settings are not visible:

Enable Public Access

Enable and Access in Outlook (OWA)

Searchable in Outlook Address Book (GAL)

Validate that switching back to Teams tab restores Group Settings section

Navigation Tests
Verify switching between Teams tab (28) and Sharepoint tab (3) correctly toggles the display

Confirm the UI updates immediately when switching tabs

Test that no visual artifacts remain during tab transitions

Data Consistency Tests
Verify Primary and Secondary owner data is preserved when switching between tabs

Validate that all other fields maintain their values during tab switches

Confirm no data loss occurs during tab navigation

UI Layout Tests
Verify proper spacing and alignment when Group Settings section is removed

Confirm the page layout adjusts smoothly to accommodate the changes

Test that no empty spaces or visual gaps appear in the interface





Functional Test Cases
General Information Validation
Verify that all mandatory fields (marked with *) are displayed correctly

Confirm the Title field shows "My Guest Team Testing-[External]" correctly

Validate the URL link https://share.novartis.net/sites/MyGuestTeamTesting is accurate

Verify "Private group | M365 Business Use Only (External)" label is displayed

Group Classification Tests
Verify Division field displays "Finance" correctly

Confirm Function shows "DATA, DIGITAL & IT"

Validate Country displays "Switzerland"

Check Data Type shows "Application Data & Interfaces"

Verify Business Criticality displays "Low"

Confirm Data Privacy shows "N/A"

Validate Owners field shows the correct user(s)

External Sharing Settings
Verify "Enable/Disable External Sharing" option is visible

Confirm "External Sharing for Private Channels" option is present

Validate all toggle switches are in correct state for read-only mode

Group Settings
Verify "Enable Public Access" option is visible

Confirm "Enable and Access in Outlook (OWA)" option is displayed

Validate "Searchable in Outlook Address Book (GAL)" option is present

Policy Links Validation
Verify all policy links are functional:

Novartis classification guidelines (go/classify)

Novartis Global Data Privacy Principles (go/privacyprinciples)

Novartis Legal Hold guidelines (go/legalholdfaqs)

Novartis Global Records Retention Schedule (go/IMF)

UI/UX Test Cases
Verify the breadcrumb navigation (Inventory > Teams) is correct

Confirm the search bar is present and properly aligned

Validate the "Delete" and "Edit" buttons are visible at the bottom

Check that all fields are non-editable in read-only mode

Verify proper formatting and alignment of all form elements

Permission Test Cases
Verify only authorized users can view this page

Confirm edit permissions are restricted appropriately

Validate delete permissions are properly configured

Navigation Test Cases
Verify all tab navigation works (Teams, Engage, Sharepoint, Streams, Planner, Others)

Confirm correct count displays on each tab (Teams(28), Engage(6), etc.)

Validate home icon navigation functionality

Non-Functional Test Cases
Performance
Verify page load time is within acceptable limits

Confirm all policy links load efficiently

Compatibility
Test screen display across different browsers

Verify responsive design for different screen sizes

Accessibility
Verify screen reader compatibility

Confirm color contrast meets accessibility standards

Validate keyboard navigation functionality





Group Classification Tests
Data Validation Tests
Verify the service endpoint returns all required classification fields

Validate that all mandatory fields (marked with *) contain non-null values

Confirm the data format matches the expected schema

Division Field Tests
Verify Division field accepts and displays dynamic values from service

Validate the mandatory (*) indicator for Division field

Confirm current value "Finance" matches with service response

Test handling of Division field updates through service

Function Field Tests
Verify Function field accepts and displays dynamic values from service

Validate the mandatory (*) indicator for Function field

Confirm current value "DATA, DIGITAL & IT" matches with service response

Test handling of Function field updates through service

Country Field Tests
Verify Country field accepts and displays dynamic values from service

Validate the mandatory (*) indicator for Country field

Confirm current value "Switzerland" matches with service response

Test handling of Country field updates through service

Data Type Field Tests
Verify Data Type field accepts and displays dynamic values from service

Validate the mandatory (*) indicator for Data Type field

Confirm current value "Application Data & Interfaces" matches with service response

Test handling of Data Type field updates through service

Business Criticality Tests
Verify Business Criticality field accepts and displays dynamic values from service

Validate the mandatory (*) indicator for Business Criticality field

Confirm current value "Low" matches with service response

Test handling of Business Criticality field updates through service

Data Privacy Tests
Verify Data Privacy field accepts and displays dynamic values from service

Validate the mandatory (*) indicator for Data Privacy field

Confirm current value "N/A" matches with service response

Test handling of Data Privacy field updates through service

Error Handling Tests
Verify appropriate error messages when service fails to fetch data

Test system behavior when service returns incomplete data

Validate error handling for network timeout scenarios

Test system recovery after service disruption

Data Refresh Tests
Verify data refresh mechanism works correctly

Test auto-refresh functionality if implemented

Validate data consistency after refresh

Test manual refresh triggers

Performance Tests
Measure response time for classification data loading

Test system behavior under high load conditions

Verify caching mechanisms if implemented

Monitor service call frequency and optimization


//first query with hardcoded data
//^(?!\s*$)([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(;[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})*$

{
  user(id: "23"){
    id,
    firstName,
    age
  }
}

// more
{
  user(id: "34") {
    id
    firstName
    age
    company {
      id
      name
      description
    }
  }
  company(id: "2") {
    id
    name
    description
    users {
      id
      firstName
      company {
        id
        name
        description
      }
    }
  }
}


// query fragment
// apple is just a reference name of query
{
  apple: company(id: 1){
    ...companyDetailFragment
  }
}

fragment companyDetailsFragment on Company{
  id
  name
  description
}

// mutation query
mutation{
  addUser(firstName: "Test User2", age: 35){
    firstName
    age
    id
  }
}

// deleteUser and editUser mutation tests

# mutation{
#   addUser(firstName: "Test User3", age: 15){
#     firstName
#     age
#     id
#   }
# }

# mutation{
#   deleteUser(userId: "A9I6fRP"){
#     id
#     firstName
#     age
#   }
# }

# {
#   user(id: "sCXS9DN"){
#     id
#     firstName
#     age
#   }
# }

mutation{
  editUser(userId: "sCXS9DN", firstName: "User 3"){
    id,
    firstName
  }
}


---

// Types.ts
export interface MeetingRoomType {
  ID: string;
  MeetingCount: number;
  DisplayName: string;
  EmailAddress: string;
  Records: number;
}

export interface MeetingRoomDetailPayload {
  MeetingId: string;
  startDate: string;
  endDate: string;
}

// Optimized date-related interfaces
export interface DateTimeInfo {
  dateTime: string;
  timeZone: string;
}

export interface EmailAddress {
  name: string;
  address: string;
}

export interface MeetingRoomGridRecordType {
  start: DateTimeInfo;
  end: DateTimeInfo;
  organizer: {
    emailAddress: EmailAddress;
  };
}

// Constants
export const ITEMS_PER_PAGE = 10;
export const DATE_FORMAT = 'DD/MM/YYYY hh:mm A';

// Context.tsx
import React, { createContext, useContext, useMemo, useCallback } from 'react';

interface MeetingRoomContextType {
  meetingInfo: MeetingRoomType | null;
  setMeetingInfo: (value: MeetingRoomType) => void;
  meetingRooms: MeetingRoomType[];
  meetingDetailParam: MeetingRoomDetailPayload | null;
  setMeetingDetailParam: (param: MeetingRoomDetailPayload) => void;
  searchString: string;
}

const MeetingRoomContext = createContext<MeetingRoomContextType>({
  meetingInfo: null,
  setMeetingInfo: () => undefined,
  meetingRooms: [],
  meetingDetailParam: null,
  setMeetingDetailParam: () => undefined,
  searchString: '',
});

// Custom hooks for context
export const useMeetingRoomCtx = () => useContext(MeetingRoomContext);

// MeetingRoomList.tsx
import React, { memo, useCallback } from 'react';
import { List, Input } from '@/components/ui/list';

interface MeetingRoomListProps {
  onPageChange: (pageNo: number) => void;
  onSearch: (value: string) => void;
}

export const MeetingRoomList = memo(({ onPageChange, onSearch }: MeetingRoomListProps) => {
  const { meetingRooms, setMeetingInfo } = useMeetingRoomCtx();
  
  const data = useMemo(() => 
    meetingRooms.map((meeting, index) => ({
      index,
      key: meeting.ID,
      content: <div><strong>{meeting.DisplayName}</strong></div>,
      endMedia: <ArrowRightIcon />,
      contentMedia: <PageRightIcon />
    })), [meetingRooms]);

  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    onSearch(e.target.value);
  }, [onSearch]);

  return (
    <div className="meeting-room-list">
      <Flex className="p-5">
        <Input
          icon={<SearchIcon />}
          clearable
          placeholder="Search..."
          fluid
          onChange={handleSearchChange}
        />
      </Flex>
      {data.length > 0 ? (
        <List
          selectable
          items={data}
          onSelectedIndexChange={useCallback(({ selectedIndex }) => {
            setMeetingInfo(meetingRooms[selectedIndex]);
          }, [meetingRooms, setMeetingInfo])}
        />
      ) : (
        <span>No records found</span>
      )}
    </div>
  );
});

MeetingRoomList.displayName = 'MeetingRoomList';

// MeetingRoomForm.tsx
import React, { memo, useCallback } from 'react';
import moment from 'moment';

export const MeetingRoomForm = memo(() => {
  const { meetingInfo, selectedDate, setSelectedDate } = useMeetingRoomCtx();
  
  const handleDateChange = useCallback((value: { startDateOnly: string, endDateOnly: string }) => {
    if (value?.startDateOnly && value?.endDateOnly) {
      setSelectedDate({
        startDate: value.startDateOnly,
        endDate: value.endDateOnly
      });
    }
  }, [setSelectedDate]);

  const startDate = useMemo(() => 
    new Date(new Date().setDate(new Date().getDate())), 
    []
  );

  return (
    <div className="meeting-room-form-container">
      <div className="meeting-room-info-form meeting-room-panel">
        <div className="meeting-room-form-item">
          <Text>Display Name</Text>
          <TextField value={meetingInfo?.DisplayName || ""} />
        </div>
        <div className="meeting-room-form-item">
          <Text>Primary SMTP Address</Text>
          <TextField value={meetingInfo?.EmailAddress || ""} />
        </div>
      </div>

      <Divider className="pr-10" />

      <div className="meeting-room-action-form meeting-room-panel">
        <RangeSelectorComponent
          isToggleable={false}
          startDateValue={startDate}
          allowFutureDateSelection={true}
          isDisabled={selectedDateType === MeetingRoomCheckBoxItem.Today}
          onValueChange={handleDateChange}
        />
      </div>
    </div>
  );
});

MeetingRoomForm.displayName = 'MeetingRoomForm';

// MeetingRoomTableComponent.tsx
import React, { memo, useCallback } from 'react';
import { Table } from '@/components/ui/table';

export const MeetingRoomTableComponent = memo(() => {
  const { list, meetingDetailParam } = useMeetingRoomCtx();

  const rowData = useMemo(() => list.map((item, index) => ({
    key: index,
    items: [
      item?.start?.dateTime ? moment(item.start.dateTime).format(DATE_FORMAT) : "",
      item?.end?.dateTime ? moment(item.end.dateTime).format(DATE_FORMAT) : "",
      item?.organizer?.emailAddress?.name || ""
    ]
  })), [list]);

  const header = {
    key: 'header',
    items: [
      { content: <strong>Start Date</strong>, key: 'startDate' },
      { content: <strong>End Date</strong>, key: 'endDate' },
      { content: <strong>Organizer</strong>, key: 'organizer' }
    ]
  };

  return (
    <div className="meeting-room-panel">
      {progress && <div className="meeting-room-table-spinner"><Spinner size={2} /></div>}
      <Table 
        compact 
        header={header} 
        rows={rowData} 
        aria-label="Meeting room table"
      />
      {!list.length && <div>No records found</div>}
    </div>
  );
});

MeetingRoomTableComponent.displayName = 'MeetingRoomTableComponent';

// Layout.tsx
export const MeetingRoomLayout = memo(({ SearchQuery = "" }) => {
  const [searchText, setSearchText] = useState("");
  const [pageNumber, setPageNumber] = useState(1);
  const [loading, setLoading] = useState(false);
  const [totalPages, setTotalPages] = useState(0);

  const loadService = useCallback(async (url: string, isSearchStringCall = false) => {
    setLoading(true);
    try {
      const res = await getMeetingRooms(url);
      if (res.status === 200) {
        const meetings = (res.data || []).map((item: any) => ({
          ...item,
        }));
        setMeetingRooms(meetings);
        setTotalPages(Math.round(meetings.length > 0 ? meetings[0].MeetingCount / ITEMS_PER_PAGE : 0));
        if (isSearchStringCall) setPageNumber(1);
      }
    } catch (err) {
      console.error("Error loading meeting rooms:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    setSearchText(SearchQuery);
  }, [SearchQuery]);

  return (
    <div>
      <MeetingRoomHeaderComponent />
      <div className="meeting-room-container">
        <MeetingRoomProvider meetingRooms={meetingRooms} searchString={searchText}>
          <div className="meeting-room-left-pane meeting-room-panel">
            <MeetingRoomList
              onPageChange={handlePageChange}
              onSearch={handleSearch}
            />
            {loading && totalPages > 0 && (
              <div className="meeting-room-list-pagination">
                <Pagination
                  currentPage={pageNumber}
                  totalPages={totalPages}
                  onPageChange={handlePageChange}
                />
              </div>
            )}
          </div>
          <div className="meeting-room-right-pane">
            <MeetingRoomInfoComponent />
          </div>
        </MeetingRoomProvider>
      </div>
    </div>
  );
});

MeetingRoomLayout.displayName = 'MeetingRoomLayout';
