Section: External Sharing Functionality

Verify Default State of External Sharing Toggle

Navigate to the OneDrive Management page and check if the External Sharing toggle is disabled by default.

Enable External Sharing and Validate Terms of Use Certification Popup

Click the toggle button to enable External Sharing and verify that the Terms of Use popup appears.

Accept Terms of Use and Successfully Enable External Sharing

Check if enabling External Sharing after accepting Terms of Use and providing a Business Justification is successful.

Attempt to Proceed Without Accepting Terms of Use

Try clicking 'Proceed' without selecting any checkboxes and verify that the button remains disabled.

Attempt to Proceed Without Business Justification

Verify that the system does not allow proceeding without filling the Business Justification field.

Disable External Sharing

Turn off the External Sharing toggle and confirm that it disables without showing Terms of Use popup.

Verify Default Expiration Period

Check if the default expiration period for external share links is set to 30 days.

Change Expiration Period to 90 Days

Modify the default expiration period to 90 days and check if the update is saved successfully.

Section: OneDrive Assisted Cleanup

Verify Assisted Cleanup Default Date

Click on 'OneDrive Assisted Cleanup' and confirm that the default cleanup date is set to 3 years prior.

Select a Different Cleanup Date and Proceed

Choose a different past date, click 'Proceed,' and validate that search results open in Edge.

Attempt to Proceed Without Selecting a Date

Clear the selected date and check if the 'Proceed' button remains disabled.

Verify Download and Delete Options in Search Results

After Assisted Cleanup search results are displayed, verify that users can download or delete files.

Section: Mobile Readiness Testing

Verify Responsive Layout on Different Screen Sizes

Test the siteâ€™s responsiveness on various screen sizes, including mobile, tablet, and desktop.

Test External Sharing Toggle on Mobile

Ensure the toggle button is fully functional and the Terms of Use popup displays correctly on mobile devices.

Validate Assisted Cleanup on Mobile

Check if the Assisted Cleanup feature works smoothly on mobile screens without layout issues.

Verify Touchscreen Usability

Ensure all interactive elements, including buttons and toggles, are easy to use on touch screens.

Section: UI and Usability Improvements

Color of Progress Bar

Verify that the progress bar displays the correct color based on usage percentage.

Change GB to TB

Ensure that storage units are correctly displayed in TB instead of GB where applicable.

Instruction UI Fix

Check if instructions are clear, correctly formatted, and visible.

OneDrive Assistance Cleanup UI Fix

Validate that the Assisted Cleanup UI is properly aligned and all buttons are functional.

OneDrive for Business External Sharing - Terms of Use and User Certification POP UI

Ensure the Terms of Use popup appears properly, is readable, and functions correctly.

Detail Hyperlink is Missing

Verify that all hyperlinks, including 'More details,' are present and functional.

Fix Review UI & Links

Ensure that all review UI components and links work correctly.

Update and Refresh is Working

Test if page updates and refresh functionality work without data loss or lag.

Notification Missing Upon Save/Update

Check if a confirmation notification is displayed when saving or updating settings.


//first query with hardcoded data
//^(?!\s*$)([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(;[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})*$

{
  user(id: "23"){
    id,
    firstName,
    age
  }
}

// more
{
  user(id: "34") {
    id
    firstName
    age
    company {
      id
      name
      description
    }
  }
  company(id: "2") {
    id
    name
    description
    users {
      id
      firstName
      company {
        id
        name
        description
      }
    }
  }
}


// query fragment
// apple is just a reference name of query
{
  apple: company(id: 1){
    ...companyDetailFragment
  }
}

fragment companyDetailsFragment on Company{
  id
  name
  description
}

// mutation query
mutation{
  addUser(firstName: "Test User2", age: 35){
    firstName
    age
    id
  }
}

// deleteUser and editUser mutation tests

# mutation{
#   addUser(firstName: "Test User3", age: 15){
#     firstName
#     age
#     id
#   }
# }

# mutation{
#   deleteUser(userId: "A9I6fRP"){
#     id
#     firstName
#     age
#   }
# }

# {
#   user(id: "sCXS9DN"){
#     id
#     firstName
#     age
#   }
# }

mutation{
  editUser(userId: "sCXS9DN", firstName: "User 3"){
    id,
    firstName
  }
}


---

// Types.ts
export interface MeetingRoomType {
  ID: string;
  MeetingCount: number;
  DisplayName: string;
  EmailAddress: string;
  Records: number;
}

export interface MeetingRoomDetailPayload {
  MeetingId: string;
  startDate: string;
  endDate: string;
}

// Optimized date-related interfaces
export interface DateTimeInfo {
  dateTime: string;
  timeZone: string;
}

export interface EmailAddress {
  name: string;
  address: string;
}

export interface MeetingRoomGridRecordType {
  start: DateTimeInfo;
  end: DateTimeInfo;
  organizer: {
    emailAddress: EmailAddress;
  };
}

// Constants
export const ITEMS_PER_PAGE = 10;
export const DATE_FORMAT = 'DD/MM/YYYY hh:mm A';

// Context.tsx
import React, { createContext, useContext, useMemo, useCallback } from 'react';

interface MeetingRoomContextType {
  meetingInfo: MeetingRoomType | null;
  setMeetingInfo: (value: MeetingRoomType) => void;
  meetingRooms: MeetingRoomType[];
  meetingDetailParam: MeetingRoomDetailPayload | null;
  setMeetingDetailParam: (param: MeetingRoomDetailPayload) => void;
  searchString: string;
}

const MeetingRoomContext = createContext<MeetingRoomContextType>({
  meetingInfo: null,
  setMeetingInfo: () => undefined,
  meetingRooms: [],
  meetingDetailParam: null,
  setMeetingDetailParam: () => undefined,
  searchString: '',
});

// Custom hooks for context
export const useMeetingRoomCtx = () => useContext(MeetingRoomContext);

// MeetingRoomList.tsx
import React, { memo, useCallback } from 'react';
import { List, Input } from '@/components/ui/list';

interface MeetingRoomListProps {
  onPageChange: (pageNo: number) => void;
  onSearch: (value: string) => void;
}

export const MeetingRoomList = memo(({ onPageChange, onSearch }: MeetingRoomListProps) => {
  const { meetingRooms, setMeetingInfo } = useMeetingRoomCtx();
  
  const data = useMemo(() => 
    meetingRooms.map((meeting, index) => ({
      index,
      key: meeting.ID,
      content: <div><strong>{meeting.DisplayName}</strong></div>,
      endMedia: <ArrowRightIcon />,
      contentMedia: <PageRightIcon />
    })), [meetingRooms]);

  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    onSearch(e.target.value);
  }, [onSearch]);

  return (
    <div className="meeting-room-list">
      <Flex className="p-5">
        <Input
          icon={<SearchIcon />}
          clearable
          placeholder="Search..."
          fluid
          onChange={handleSearchChange}
        />
      </Flex>
      {data.length > 0 ? (
        <List
          selectable
          items={data}
          onSelectedIndexChange={useCallback(({ selectedIndex }) => {
            setMeetingInfo(meetingRooms[selectedIndex]);
          }, [meetingRooms, setMeetingInfo])}
        />
      ) : (
        <span>No records found</span>
      )}
    </div>
  );
});

MeetingRoomList.displayName = 'MeetingRoomList';

// MeetingRoomForm.tsx
import React, { memo, useCallback } from 'react';
import moment from 'moment';

export const MeetingRoomForm = memo(() => {
  const { meetingInfo, selectedDate, setSelectedDate } = useMeetingRoomCtx();
  
  const handleDateChange = useCallback((value: { startDateOnly: string, endDateOnly: string }) => {
    if (value?.startDateOnly && value?.endDateOnly) {
      setSelectedDate({
        startDate: value.startDateOnly,
        endDate: value.endDateOnly
      });
    }
  }, [setSelectedDate]);

  const startDate = useMemo(() => 
    new Date(new Date().setDate(new Date().getDate())), 
    []
  );

  return (
    <div className="meeting-room-form-container">
      <div className="meeting-room-info-form meeting-room-panel">
        <div className="meeting-room-form-item">
          <Text>Display Name</Text>
          <TextField value={meetingInfo?.DisplayName || ""} />
        </div>
        <div className="meeting-room-form-item">
          <Text>Primary SMTP Address</Text>
          <TextField value={meetingInfo?.EmailAddress || ""} />
        </div>
      </div>

      <Divider className="pr-10" />

      <div className="meeting-room-action-form meeting-room-panel">
        <RangeSelectorComponent
          isToggleable={false}
          startDateValue={startDate}
          allowFutureDateSelection={true}
          isDisabled={selectedDateType === MeetingRoomCheckBoxItem.Today}
          onValueChange={handleDateChange}
        />
      </div>
    </div>
  );
});

MeetingRoomForm.displayName = 'MeetingRoomForm';

// MeetingRoomTableComponent.tsx
import React, { memo, useCallback } from 'react';
import { Table } from '@/components/ui/table';

export const MeetingRoomTableComponent = memo(() => {
  const { list, meetingDetailParam } = useMeetingRoomCtx();

  const rowData = useMemo(() => list.map((item, index) => ({
    key: index,
    items: [
      item?.start?.dateTime ? moment(item.start.dateTime).format(DATE_FORMAT) : "",
      item?.end?.dateTime ? moment(item.end.dateTime).format(DATE_FORMAT) : "",
      item?.organizer?.emailAddress?.name || ""
    ]
  })), [list]);

  const header = {
    key: 'header',
    items: [
      { content: <strong>Start Date</strong>, key: 'startDate' },
      { content: <strong>End Date</strong>, key: 'endDate' },
      { content: <strong>Organizer</strong>, key: 'organizer' }
    ]
  };

  return (
    <div className="meeting-room-panel">
      {progress && <div className="meeting-room-table-spinner"><Spinner size={2} /></div>}
      <Table 
        compact 
        header={header} 
        rows={rowData} 
        aria-label="Meeting room table"
      />
      {!list.length && <div>No records found</div>}
    </div>
  );
});

MeetingRoomTableComponent.displayName = 'MeetingRoomTableComponent';

// Layout.tsx
export const MeetingRoomLayout = memo(({ SearchQuery = "" }) => {
  const [searchText, setSearchText] = useState("");
  const [pageNumber, setPageNumber] = useState(1);
  const [loading, setLoading] = useState(false);
  const [totalPages, setTotalPages] = useState(0);

  const loadService = useCallback(async (url: string, isSearchStringCall = false) => {
    setLoading(true);
    try {
      const res = await getMeetingRooms(url);
      if (res.status === 200) {
        const meetings = (res.data || []).map((item: any) => ({
          ...item,
        }));
        setMeetingRooms(meetings);
        setTotalPages(Math.round(meetings.length > 0 ? meetings[0].MeetingCount / ITEMS_PER_PAGE : 0));
        if (isSearchStringCall) setPageNumber(1);
      }
    } catch (err) {
      console.error("Error loading meeting rooms:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    setSearchText(SearchQuery);
  }, [SearchQuery]);

  return (
    <div>
      <MeetingRoomHeaderComponent />
      <div className="meeting-room-container">
        <MeetingRoomProvider meetingRooms={meetingRooms} searchString={searchText}>
          <div className="meeting-room-left-pane meeting-room-panel">
            <MeetingRoomList
              onPageChange={handlePageChange}
              onSearch={handleSearch}
            />
            {loading && totalPages > 0 && (
              <div className="meeting-room-list-pagination">
                <Pagination
                  currentPage={pageNumber}
                  totalPages={totalPages}
                  onPageChange={handlePageChange}
                />
              </div>
            )}
          </div>
          <div className="meeting-room-right-pane">
            <MeetingRoomInfoComponent />
          </div>
        </MeetingRoomProvider>
      </div>
    </div>
  );
});

MeetingRoomLayout.displayName = 'MeetingRoomLayout';
